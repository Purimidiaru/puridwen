{
  "version": 3,
  "sources": ["../../svelte/src/legacy/legacy-client.js"],
  "sourcesContent": ["/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\nimport { DIRTY, LEGACY_PROPS, MAYBE_DIRTY } from '../internal/client/constants.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { active_effect, flushSync, get, set_signal_status } from '../internal/client/runtime.js';\nimport { lifecycle_outside_component } from '../internal/shared/errors.js';\nimport { define_property, is_array } from '../internal/shared/utils.js';\nimport * as w from '../internal/client/warnings.js';\nimport { DEV } from 'esm-env';\nimport { FILENAME } from '../constants.js';\nimport { component_context, dev_current_component_function } from '../internal/client/context.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {ComponentConstructorOptions<Props> & {\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\n * }} options\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Support using the component as both a class and function during the transition period\n * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType\n */\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {ComponentConstructorOptions & {\n\t *  component: any;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tvar sources = new Map();\n\n\t\t/**\n\t\t * @param {string | symbol} key\n\t\t * @param {unknown} value\n\t\t */\n\t\tvar add_source = (key, value) => {\n\t\t\tvar s = mutable_source(value, false, false);\n\t\t\tsources.set(key, s);\n\t\t\treturn s;\n\t\t};\n\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\n\t\t// each property, which is incremented on updates to the property itself. Do not\n\t\t// use our $state proxy because that one has fine-grained reactivity.\n\t\tconst props = new Proxy(\n\t\t\t{ ...(options.props || {}), $$events: {} },\n\t\t\t{\n\t\t\t\tget(target, prop) {\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t},\n\t\t\t\thas(target, prop) {\n\t\t\t\t\t// Necessary to not throw \"invalid binding\" validation errors on the component side\n\t\t\t\t\tif (prop === LEGACY_PROPS) return true;\n\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t\treturn Reflect.has(target, prop);\n\t\t\t\t},\n\t\t\t\tset(target, prop, value) {\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\n\t\t\t\t\treturn Reflect.set(target, prop, value);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tanchor: options.anchor,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro ?? false,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\t// We don't flushSync for custom element wrappers or if the user doesn't want it\n\t\tif (!options?.props?.$$host || options.sync === false) {\n\t\t\tflushSync();\n\t\t}\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(() => {\n\t\tfn();\n\t\tvar effect = /** @type {import('#client').Effect} */ (active_effect);\n\t\t// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour\n\t\tif ((effect.f & DIRTY) !== 0) {\n\t\t\tlet filename = \"a file (we can't know which one)\";\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tfilename = dev_current_component_function?.[FILENAME] ?? filename;\n\t\t\t}\n\t\t\tw.legacy_recursive_reactive_block(filename);\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t});\n}\n\n/**\n * Function to mimic the multiple listeners available in svelte 4\n * @deprecated\n * @param {EventListener[]} handlers\n * @returns {EventListener}\n */\nexport function handlers(...handlers) {\n\treturn function (event) {\n\t\tconst { stopImmediatePropagation } = event;\n\t\tlet stopped = false;\n\n\t\tevent.stopImmediatePropagation = () => {\n\t\t\tstopped = true;\n\t\t\tstopImmediatePropagation.call(event);\n\t\t};\n\n\t\tconst errors = [];\n\n\t\tfor (const handler of handlers) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error `this` is not typed\n\t\t\t\thandler?.call(this, event);\n\t\t\t} catch (e) {\n\t\t\t\terrors.push(e);\n\t\t\t}\n\n\t\t\tif (stopped) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let error of errors) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.\n * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\n */\nexport function createBubbler() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createBubbler');\n\t}\n\n\treturn (/**@type {string}*/ type) => (/**@type {Event}*/ event) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\nexport {\n\tonce,\n\tpreventDefault,\n\tself,\n\tstopImmediatePropagation,\n\tstopPropagation,\n\ttrusted,\n\tpassive,\n\tnonpassive\n} from '../internal/client/dom/legacy/event-modifiers.js';\n"],
  "mappings": "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",
  "names": ["handlers", "stopImmediatePropagation"]
}
